### Соломахин Владислав
### Урок 60 

### 1) Что такое функция? Чем она отличается от процедуры?
   Функция — это блок кода, который принимает входные параметры, выполняет определенные операции и возвращает значение. Процедура, в отличие от функции, не возвращает значения, а просто выполняет действия. Основное различие состоит в том, что функции возвращают результат, а процедуры — нет.

### 2) Как оформляются функции в тексте программы (сравните школьный алгоритмический язык и Паскаль)?
   В школьном алгоритмическом языке функции часто оформляются просто с указанием их названия и входных параметров, без строгого определения типов. Например:
      Функция Максимум(а, b)
       Если а > b тогда
           Вернуть а
       Иначе
           Вернуть b
   КонецФункции
   
   В Паскале функции имеют строгую структуру с указанием типа возвращаемого значения и определением типов параметров:
      function Максимум(a, b: Integer): Integer;
   begin
       if a > b then
           Максимум := a
       else
           Максимум := b;
   end;
   

### 3) Как по тексту программы определить, какое значение возвращает функция? Приведите пример.
   Чтобы определить значение, возвращаемое функцией, следует изучить ее тело и выйти на оператор, который возвращает соответствующее значение. Например:
      function Сумма(a, b: Integer): Integer;
   begin
       Сумма := a + b;
   end;
   
   В данном случае функция Сумма возвращает сумму двух целых чисел.

### 4) Какие функции называются логическими? Зачем они нужны?
   Логические функции — это функции, которые возвращают булевы значения (истина или ложь). Они часто используются для проверок и условий, например, для определения, является ли число простым, или для работы с условиями в логических выражениях.

### Сообщения

а) Функции в языке Си
   Функции в языке Си определяются с указанием типа возвращаемого значения, имени функции и параметров. Синтаксис выглядит следующим образом:
      return_type function_name(parameter_list) {
       // тело функции
   }
   
   Пример функции, вычисляющей сумму двух чисел:
      int sum(int a, int b) {
       return a + b;
   }
   

б) Функции в языке Python
   В Python функции определяются с использованием ключевого слова def и не требуют указания типов параметров. Пример функции, вычисляющей произведение двух чисел:
      def multiply(a, b):
       return a * b
   

### Задачи

### 1) Напишите функцию, которая вычисляет максимальное из трёх чисел.
def max_of_three(a, b, c):
    return max(a, b, c)


### 2) Напишите функцию, которая вычисляет сразу максимальное и минимальное из трёх чисел.
def min_max_of_three(a, b, c):
    return (min(a, b, c), max(a, b, c))


### 3) Напишите функцию, которая вычисляет количество цифр числа.
def count_digits(n):
    return len(str(abs(n)))  # abs для обработки отрицательных чисел


### 4) Напишите функцию, которая вычисляет наибольший общий делитель двух чисел.
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a


### 5) Напишите функцию, которая вычисляет наименьшее общее кратное двух чисел.
def lcm(a, b):
    return abs(a * b) // gcd(a, b)


### 6)  Напишите функцию, которая «разворачивает» десятичную запись числа. 
def reverse_number(n):
    return int(str(n)[::-1])


### 7) Напишите функцию, которая моделирует бросание двух игральных кубиков.
import random

def throw_dice():
    return (random.randint(1, 6), random.randint(1, 6))


### 8) Напишите функцию, которая вычисляет факториал натурального числа М.
def factorial(m):
    if m == 0:
        return 1
    else:
        return m * factorial(m - 1)


### 9) Напишите функцию, которая вычисляет N-е число Фибоначчи.
def fibonacci(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)


### 10) Напишите функцию, которая находит все пары дружественных чисел.
def sum_of_divisors(n):
    return sum(i for i in range(1, n) if n % i == 0)
    def amicable_numbers(limit):
    pairs = []
    for i in range(1, limit):
        j = sum_of_divisors(i)
        if j < limit and i != j and sum_of_divisors(j) == i:
            pairs.append((i, j))
    return pairs


### 11) Напишите программу, которая находит все числа на отрезке 0, N, сумма цифр которых не меняется при умножении на 2, 3, 4, 5, 6, 7, 8 и 9.
def digit_sum(n):
    return sum(int(digit) for digit in str(n))

def find_same_digit_sum(N):
    result = []
    for i in range(N + 1):
        if all(digit_sum(i) == digit_sum(i * j) for j in range(2, 10)):
            result.append(i)
    return result


### 12) Напишите логическую функцию, которая определяет, является ли число совершенным.
def is_perfect(n):
    return n == sum(i for i in range(1, n) if n % i == 0)


### 13) Напишите логическую функцию, которая определяет, является ли число гиперпростым.
def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def is_hyperprime(n):
    str_n = str(n)
    # Проверяем все возможные числа, которые можно получить, удалив цифры
    for i in range(len(str_n)):
        for j in range(i+1, len(str_n) + 1):
            if not is_prime(int(str_n[i:j])):
                return False
    return True


### Урок 61

### 1) Что такое рекурсия? Приведите примеры.
   Рекурсия — это метод, при котором функция вызывает саму себя для решения более мелких подзадач. Примером рекурсивной функции является вычисление факториала:
      Факториал(n) = n * Факториал(n-1), если n > 1
   Факториал(1) = 1
   

### 2) Почему любое рекурсивное определение состоит из двух частей?
   Рекурсивное определение состоит из двух частей: базового случая (условия, при котором рекурсия останавливается) и рекурсивного случая (где функция вызывает саму себя для решения подзадачи). Это необходимо для предотвращения бесконечной рекурсии и обеспечения завершенности.

### 3) Что такое рекурсивная процедура (функция)?
   Рекурсивная процедура или функция — это такая, которая вызывает саму себя в своем теле. Например, функция для вычисления чисел Фибоначчи:
      Фиб(n) = Фиб(n-1) + Фиб(n-2) при n > 1
   Фиб(0) = 0, Фиб(1) = 1
   

### 4) Расскажите о задаче «Ханойские башни». Попытайтесь придумать алгоритм её решения, не использующий рекурсию.
   Задача «Ханойские башни» состоит в том, чтобы переместить набор дисков с одного стержня на другой, используя третий стержень, при условии, что больше дисков нельзя помещать на меньшие. Рекурсивное решение заключается в перемещении n-1 дисков, а затем перемещении n-го диска.

   Нерекурсивный алгоритм требует использования стека или очереди для отслеживания перемещений. Можно воспользоваться итеративным подходом и посчитать количество перемещений, а затем воспользоваться битовыми операциями для выяснения, какой диск стоит переместить на каждом этапе.

### 5) Процедура А вызывает процедуру Б, а процедура Б — процедуру А и саму себя. Какую из этих процедур можно назвать рекурсивной?
   Процедуру Б можно назвать рекурсивной, если она вызывает саму себя. Процедура А может быть взаиморекурсивной, если она вызывает процедуру Б, а та уже вызывает А.

### 6) В каком случае рекурсия никогда не остановится? Докажите, что в рассмотренных в параграфе задачах этого не случится.
   Рекурсия никогда не остановится, если отсутствует базовый случай или условие, при котором рекурсия завершается. Например, если функция всегда вызывает себя с одинаковыми параметрами, это приведет к бесконечной рекурсии. В задачах, рассмотренных в параграфе, базовые случаи со строгими условиями (например, 0 для факториала) предотвратят бесконечность.

### 7) Что такое стек? Как он используется при выполнении программ?
   Стек — это структура данных, работающая по принципу LIFO (последний пришел — первый вышел). В программировании стек используется для хранения контекста выполнения функций, включая локальные переменные и адрес возврата, что позволяет осуществлять управление памятью и выполнять рекурсию.

### 8) Почему при использовании рекурсии может случиться переполнение стека?
   Переполнение стека может произойти, если функции вызывают друг друга слишком много раз без достижения базового случая. Это приводит к тому, что стек затаскивает все больше и больше уровней вызова, что в конечном итоге приводит к недостатку памяти.

### 9) Назовите достоинства и недостатки рекурсии. Когда её следует использовать, а когда нет?
   Достоинства:
   - Упрощение кода и логики задач, особенно для структур, таких как деревья и графы.
   - Чистота и ясность алгоритмов.

   Недостатки:
   - Возможное переполнение стека.
   - Более высокие затраты на память и вычислительные ресурсы.
   - Иногда может быть сложнее проанализировать производительность.

   Рекурсию следует использовать при решении задач, которые естественно разбиваются на подзадачи (например, сортировка, обход деревьев). Не стоит использовать рекурсию, если известно, что глубина рекурсии может быть значительной или когда производительность критична.

### Сообщения

а) Фракталы
   Фракталы — это геометрические фигуры, которые показывают самоподобие на разных масштабах. Они могут быть созданы с помощью простых рекурсивных алгоритмов. Пример фрактала — треугольник Серпинского, который разделяется на более мелкие треугольники.

б) Числа ФибоначчиЧисла Фибоначчи — это последовательность, в которой каждое число является суммой двух предыдущих, начиная с 0 и 1. Они часто появляются в природе, в архитектуре и в искусстве.

в) Рекурсия вокруг нас
   Рекурсия присутствует в природе (например, в структуре растений) и в архитектуре (фракталы, самоподобные узоры). Рекурсия помогает моделировать сложные системы и создавать алгоритмы для их анализа.

г) Рекурсия в программировании: за и против
   Рекурсия позволяет упростить написание кода, особенно для задач, связанных с иерархическими структурами. Однако она требует осторожности из-за потенциального переполнения стека и возможной большой вычислительной нагрузки.

д) Рекурсия в произведениях искусства
   Рекурсивные паттерны можно увидеть в праздниках, архитектурных стилях и даже в музыке. Художники иногда используют фрактальные методы для создания своих произведений, что приводит к необычным и завораживающим структурам.

### Задачи

### 1) Придумайте свою рекурсивную фигуру и опишите её.
   Примером рекурсивной фигуры может быть фрактал «дерево». Это дерево строится путем отрисовки ствола и разветвлений, где каждое ветвление также может быть представлено как еще одно дерево. Каждый уровень деревьев уменьшает длину ствола и угол наклона.

### 3) Напишите рекурсивную процедуру для перевода числа в двоичную систему.
      def to_binary(n):
       if n > 1:
           to_binary(n // 2)
       print(n % 2, end='')

   to_binary(10)  # Вывод: 1010
   
# 5) Напишите рекурсивную процедуру для перевода числа из двоичной системы в десятичную.
      def binary_to_decimal(n):
       if n == 0:
           return 0
       else:
           return (n % 10) + 2 * binary_to_decimal(n // 10)

   print(binary_to_decimal(1010))  # Вывод: 10
